// ****** defining global variable default values (can be changed by the dialog input)


// nucleus detection module parameters
var hoechstChannel = 1;// channel where the hoechst signal is, used to segment nuclei
var pol2Channel = 4; // channel where the pol2 signal is, used to detect clusters
var NucleusQuantChannelOfInterest = 3;// channel where the signal for whole-nucleus intensity measurements is located
var fftSmall = 60; // minimum size of objects retained by the bandpass filter used to segment nuclei
var fftLarge = 2000; // maximum size of objects retained by the bandpass filter used to segment nuclei
var border = 1; // padding (in pixels) around each nuclei in its individually cropped stack
var nMaxObjectVolume=20; // maximum number of candidate nuclei to go through in order to select the largest ones that satisfy the surface to volume ratio criterion
var SurfaceToVolumeRatioThreshold=1.2; // maximum allowed surface/volume ratio allowed for a correctly segmented nuclei (artefactual objects are often non round and have large surface/volume)
var MaxOutputObject=15; // maximum number of nuclei to keep at the end of the segmentation (15 ensures only largest nuclei, i.e. nurse cells are retained, excluding follicle cells nuclei)

// cluster detection module parameters
var threshFactor = 3;
var MedianFilterRadiusClusters = 2; // radius of the median filter used to smooth salt and pepper noise (makes thresholding more robust)
var MedianFilterRadiusBackground = 50; // radius of the median filter used to smooth out large background features.

// whether or not to display lots of log
verbose = true;

var saveStacks = 0; // harcoded variable; suggested setting 0; set to 1 to save stacks with only the nucleus segmentation added (these stacks are generated by cropNuclei as an intermediate step redundant with the final output)

// global variable storing the number of nuclei found in the image
var nucleiFound = 0;

macro "polII_cluster_crop_analysis" {

	setBatchMode(true);

	// pop up dialog box to input the parameters
	inputParameters();
	saveDir = getDirectory("choose the output directory");
	csvSaveDir = mkDirIfNotThere(saveDir,"csvFIJI/");
	tifSaveDir = mkDirIfNotThere(saveDir,"tifFIJI/");
	
	// collect original image title
	originalImgTitle = getTitle();
	getDimensions(originalImgSizeX, originalImgSizeY, originalImgC, originalImgSizeZ, originalImgF);

	// de-trend Z loss of intensity
	print("detrending image along Z...");
	deTrendedImgTitle = "zCorrImg";
	eggChamberIntensityMeasurementAllChannels2(
		"eggChamber",originalImgTitle,hoechstChannel,deTrendedImgTitle);

	
	// segment nuclei - output is a single channel image called initiallySegmentedNuclei
	// which stores the nuclei IDs. At this stage all nuclei are segmented (nurse + follicle cells)
	print("segmenting nuclei...");
	segmentNuclei3D(deTrendedImgTitle,"firstSegResult",hoechstChannel,fftSmall,fftLarge);
	
	// isolates the desired nurse cell nuclei from the undesired follicle cells nuclei based on morphology
	print("isolating nurse cells from follicle cells");
	selectCorrectlySegmentedNuclei("firstSegResult","cleanNuclei",
		nMaxObjectVolume,SurfaceToVolumeRatioThreshold,MaxOutputObject);

	// merge clean segmentation result with initial input image, 
	//and capture the index of the channel where the nuclei segmentations are located (last channel), used in the following function
	addChannelToImg(deTrendedImgTitle,"cleanNuclei","mergedSegmentation",0);
	selectWindow("mergedSegmentation");
	getDimensions(sizeX, sizeY, C, sizeZ, F);
	maskChannel = C;
	
	// compute average intensity of each nucleus in all channels (based on masks in the channel with index maskChannel)  
	// Also computes the centroid and other geometry info - then saves it in the folder saveDir using names with the format: 
	// C1_nucInt.csv, C2_nucInt.csv, etc for intensity features
	//single file nucleiGeom.csv for geometry features 
	nucleiIntensityAndGeometryMeasurementAllChannels(csvSaveDir,"mergedSegmentation",maskChannel);

	// compute background intensity measurement across entire image then save to directory in the argument
	// files names as C1_wholeImgInt.csv, C2_wholeImgInt.csv, etc.
	wholeImgIntensityMeasurementAllChannels(csvSaveDir,"mergedSegmentation");

	// compute background intensity measurement across mask of the egg chamber - then saves it in the folder saveDir using names with the format: 
	// C1_eggChamberInt.csv, C2_eggChamberInt.csv, etc for intensity features
	eggChamberIntensityMeasurementAllChannels(csvSaveDir,"mergedSegmentation",NucleusQuantChannelOfInterest);
	
	// generate a cropped image for each nucleus that holds the original image channels 
	// plus the nuclear mask as an extra color channel
	// images are called "croppedNucleus"+label+"wSeg_masks.tif"
	print("cropping nuclei...");
	cropNuclei("mergedSegmentation",border,saveStacks);

	// loop through nuclei, segment nucleoplasm and clusters
	for (label = 1; label <= nucleiFound; label++) {
		print("processing nucleus "+label+"...");
		curImg = "croppedNucleus"+label+"wSeg";

		// compute nucleus geometry in cropped image - the centroid coordinates can 
		// then be used to convert local coordiantes (i.e. relative to the cropped img)
		// into global ones (i.e. relative to the global egg chamber img).
		nucleiGeometryMeasurement(curImg,maskChannel,csvSaveDir+ "nuc"+label+"_localGeom.csv"); 
		
		// segment nucleoplasm - output is an 8-bit mask image called maskedNucleoplasmImgTitle
		// where background is 0 and nucleoplasm is 255.
		print("segmenting nucleoplasm of nucleus "+label+"...");
		maskedNucleoplasmImgTitle = "maskedNucleusIntensity";
	  	segmentNucleoplasm(curImg,pol2Channel,maskedNucleoplasmImgTitle);

	  	//subtract the average signal value in the nucleoplasm from all channels
	  	print("subtracting background of nucleus "+label+"...");
	  	imgBgCorr = "backgroundCorrectedImg";
		subtractBackground32bit3D(curImg,maskedNucleoplasmImgTitle,imgBgCorr);
		
	  	// segment clusters - output is a 16 bit image called maskedClustersImgTitle
	  	// where background is 0 and each cluster carries an individual ID
	  	print("detecting clusters of nucleus "+label+"...");
	  	maskedClustersImgTitle = "clusterMask";
	  	detectClusters(imgBgCorr,maskedClustersImgTitle,pol2Channel,
	  		MedianFilterRadiusClusters,MedianFilterRadiusBackground,
	  		maskedNucleoplasmImgTitle,threshFactor);
		
		// compute parameters of clusters and save results
	  	print("computing cluster stats of nucleus "+label+" from raw stack...");
	  	computeClusterStats(curImg,maskedClustersImgTitle,csvSaveDir,label,"_clustInt_raw.csv");
		
	  	// compute parameters of clusters and save results
	  	print("computing cluster stats of nucleus "+label+" from nucleoplasm-corrected stack...");
	  	computeClusterStats(imgBgCorr,maskedClustersImgTitle,csvSaveDir,label,"_clustInt_plasmCorr.csv");

	  	// generate output image that includes the original hyperstack plus 3 extra channels appended at the end:
	  	// (1) the masks of the nucleus,
	  	// (2) the mask of the nucleoplasm and 
	  	// (3) the mask of the Pol II clusters	
	  	print("generating output image of nucleus "+label+"...");
	  	imgOutName = "nuc"+label +"_masks.tif";
	  	selectWindow(maskedNucleoplasmImgTitle);
	  	run("16-bit");
	  	addChannelToImg(curImg,maskedNucleoplasmImgTitle,"tmp",1);
	  	addChannelToImg("tmp",maskedClustersImgTitle,imgOutName,1);
		selectWindow("tmp");
		close();
		selectWindow(curImg);
		close();
		
	  	// collect intensity measurements on the nucleoplasm
		nucleoplasmIntensityAndGeometryMeasurementAllChannels(
			csvSaveDir,"nuc"+label,imgOutName,maskChannel+1);
		
		// save image with masks
		selectWindow(imgOutName);
	  	save(tifSaveDir+imgOutName);

		// save nucleoplasm-background corrected image
		bgCorrImgOutName = "nuc"+label +"_masks_plasmCorr.tif";
	  	print("generating output background-corrected image of nucleus "+label+"...");
	  	addChannelToImg(imgBgCorr,maskedNucleoplasmImgTitle,"tmp",0);
	  	addChannelToImg("tmp",maskedClustersImgTitle,bgCorrImgOutName,0);
		selectWindow(bgCorrImgOutName);
	  	save(tifSaveDir+bgCorrImgOutName);
	}
	
	print("saving parameters to file...");
	saveParametersToLogFile(originalImgTitle,saveDir,
		originalImgSizeX, originalImgSizeY, originalImgC, originalImgSizeZ,
		hoechstChannel,pol2Channel,NucleusQuantChannelOfInterest,fftSmall,fftLarge,
		border,nMaxObjectVolume,SurfaceToVolumeRatioThreshold,
		MaxOutputObject,threshFactor,MedianFilterRadiusClusters,
		MedianFilterRadiusBackground,nucleiFound);
	
  	setBatchMode("exit and display");
  	print("done.");
}

function eggChamberIntensityMeasurementAllChannels2(maskType,
	inputWindowName,measurementChannel,deTrendedIntTitle){
	
	// generate a mask that encompasses the egg chamber (or the whole image, 
	// depending on the flag maskType), to be used for measurements of the avg intensity vs z.
	
	selectWindow(inputWindowName);
	run("Duplicate...", "duplicate channels="+measurementChannel);
	if (maskType == "eggChamber"){
		run("Bandpass Filter...", "filter_large=2000 filter_small=100 suppress=None tolerance=5 process");
		run("Auto Threshold", "method=Default white stack");
	}else{
		setThreshold(0, 65535);
		run("Convert to Mask", "method=Default background=Dark black");
	}
	rename("mask");
	
	// compute minimum intensity in each channel across the entire z-stack 
	//- this offset will then be subtracted from the raw data.
	computeMinInt(inputWindowName,"minWholeImg");

	// subtract channel minimum (computed across entire stack) from each channel 
	subtractBackgroundGlobally(inputWindowName,"minWholeImg","dataMinusOffset");
	
	// compute mean intensity within the mask in each slice z,c 
	// output is "meanEggChamber", a 16-bit 2D image (nz nc) holdig the mean
	computeMeanZTrend("dataMinusOffset","mask","meanEggChamber");
	
	// fit the the eggchamber mean intensity as a function of Z to a line
	// in each channel using "meanEggChamber" as an input.
	// output the linear trend "linTrend", a 16-bit 2D image (nz nc) holdig the fit
	computeLinearTrendAlongX("meanEggChamber","linTrend");

	// from input hyperstack dataMinusOffset and the 2D image "linTrend" holding the linear trend vs z by channel 
	// generates a corrected hyperstack deTrendedIntTitle (nx ny nz nc) where the intensity in each slice is corrected
	// Icorr(x,y,z,c) = Iinput(x,y,z,c) * linTrend(0,c) / linTrend(z,c)
	correctIntensityForZTrend("dataMinusOffset","linTrend",deTrendedIntTitle);

	selectWindow("linTrend");
	close();
	selectWindow("minWholeImg");
	close();
	selectWindow("meanEggChamber");
	close();
	selectWindow("dataMinusOffset");
	close();
	selectWindow("mask");
	close();

	// concert back to 16 bit
	selectWindow(deTrendedIntTitle);
	for (i = 1; i <= 4; i++) {
		Stack.setPosition(i, 1, 1);
		setMinAndMax(0, 65535);
	}
	run("16-bit");
	
}

// computes min intensity across each z,c slice of the input hyperstack
// returns it as an (nz,nc) 2D image
function computeMinInt(inputWindowName,minTitle){
	selectWindow(inputWindowName);
	getDimensions(sizeX, sizeY, C, sizeZ, F);
	newImage(minTitle, "16-bit", sizeZ, C, 1);
	for(izs = 0; izs<sizeZ; izs++) {
		for (i = 0; i < C; i++) {
		    selectWindow(inputWindowName);
		    Stack.setPosition(i+1, izs+1, 1);
		    run("Select All");
		    getStatistics(area, mean, minImg, max, std, histogram);
			selectWindow(minTitle);
			setPixel(izs, i, minImg);
		}
	}
}

// from an input hyperstack inputImgTitle (nx ny nz nc), 
// and minTitle, an nz,nc 2D image holding the minimum value at each slice
// computes the global minimum across the entire stack for each channel 
// and subtracts it from the input hyperstack. 
// Outputs the subtracted image called outputImgTitle
function subtractBackgroundGlobally(inputImgTitle,minTitle,outputImgTitle){
	selectWindow(inputImgTitle);
	getDimensions(sizeX, sizeY, C, sizeZ, F);

	//duplicate input hyperstack
	run("Select All");
	run("Duplicate...", "duplicate");
	rename(outputImgTitle);
	run("32-bit");

	// compute absolute minimum in each channel, i.e. find the minimum of each row
	// of minTitle
	minArray = newArray(sizeY);
	selectWindow(minTitle);
	for (j = 0; j < C; j++) {
		for (i = 0; i < sizeZ; i++) {
			if(i==0){
				minArray[j] = getPixel(i,j);
			}else{
				x = getPixel(i,j);
				if(x<minArray[j]){
					minArray[j] = x;
				}
			}
		}
	}
	
	// subtract absolute minimum to each slice
	for(izs = 0; izs<sizeZ; izs++) {
		for(ic = 0; ic<C; ic++) {
			selectWindow(outputImgTitle);
			Stack.setPosition(ic+1, izs+1, 1);
			run("Subtract...", "value="+ minArray[ic] +" slice");
		}
	}
}	

// from an input hyperstack inputImgTitle (nx ny nz nc), 
// and a 2D image linTrendTitle (nz,nc) holding the linear trend vs z by channel 
// generates a corrected hyperstack outputImgTitle (nx ny nz nc) where the intensity in each slice is corrected
// Icorr(x,y,z,c) = Iinput(x,y,z,c) * linTrend(0,c) / linTrend(z,c)
function correctIntensityForZTrend(inputImgTitle,linTrendTitle,outputImgTitle){
	selectWindow(inputImgTitle);
	run("32-bit");
	getDimensions(sizeX, sizeY, C, sizeZ, F);

	selectWindow(linTrendTitle);
	run("32-bit");
	getDimensions(trendX, trendY, trendC, trendZ, trendF);

	// check that dimensions of the inputs are consistent with each other
	if(trendX != sizeZ){
		print("trend has "+trendX+" rows, whereas the number of slices is "+sizeZ);
		return;
	}
	if(trendY != C){
		print("trend has "+trendY+" rows, whereas the number of channels is "+C);
		return;
	}

	// get the reference level in ech channel at the first frame
	trendRef = newArray(C);
	for(ic = 0; ic<C; ic++) {	
		selectWindow(linTrendTitle);
		trendRef[ic] = getPixel(0, ic);
	}

	// normalize each channel to its first z-slize
	selectWindow(inputImgTitle);
	run("Select All");
	run("Duplicate...", "duplicate");
	rename(outputImgTitle);
	run("32-bit");
	curTrend = newArray(C);
	for(izs = 0; izs<sizeZ; izs++) {
		for(ic = 0; ic<C; ic++) {
			selectWindow(linTrendTitle);
			curTrend[ic] = getPixel(izs, ic)/trendRef[ic];
			//print("ic="+ic"; izs = "+izs+"; curTrend: "+curTrend[ic]);
			
			selectWindow(outputImgTitle);
			Stack.setPosition(ic+1, izs+1, 1);
			run("Divide...", "value="+ curTrend[ic] +" slice");
		}
	}
}

// from hyperstack hsTitle (nx ny nz nc), 
// and a mask maskTitle (nx nz nz 1 8-bit stack) at each z-slice
// computes the mean within the mask as a function of z and c
// outputs is a 16-bit 2D image meanTrendTitle (nz nc) holdig the mean
function computeMeanZTrend(hsTitle,maskTitle,meanTrendTitle){
	selectWindow(hsTitle);
	getDimensions(sizeX, sizeY, C, sizeZ, F);
	newImage(meanTrendTitle, "16-bit", sizeZ, C, 1);
	
	for(izs = 0; izs<sizeZ; izs++) {
		roiManager("reset");
	    selectWindow(maskTitle);
	    Stack.setPosition(1, izs+1, 1);
	    setThreshold(100, 255);
	    run("Create Selection");
	    roiManager("Add");
		for (i = 0; i < C; i++) {
		    selectWindow(hsTitle);
		    Stack.setPosition(i+1, izs+1, 1);
			roiManager("Select", 0);
			getStatistics(area, meanEC, minImg, max, std, histogram);
		    selectWindow(meanTrendTitle);
			setPixel(izs, i, meanEC);
		}
	}
}

// takes input 2D image inputImg and generates a 2D image titled linTrend
// with same size where the value of each pixel (x,y) 
// is equal the linear interpolation of its row
// after least square fitting I(i,j) = a(j)*i+b(j)
function computeLinearTrendAlongX(inputImg,linTrend){
	selectWindow(inputImg);
	getDimensions(sizeX, sizeY, C, sizeZ, F);

	// fill an image with x coordinate value
	newImage("x", "32-bit", sizeX, sizeY, 1);
	for (i = 0; i < sizeX; i++) {
		for (j = 0; j < sizeY; j++) {
			setPixel(i, j, i);
		}
	}
	
	newImage("sx", "32-bit", sizeX, sizeY, 1);
	curX = 0;
	for (i = 0; i < sizeX; i++) {
		curX = curX+i;
		for (j = 0; j < sizeY; j++) {
			setPixel(i, j, curX);
		}
	}

	newImage("sx2", "32-bit", sizeX, sizeY, 1);
	curX2 = 0;
	for (i = 0; i < sizeX; i++) {
		curX2 = curX2+i*i;
		for (j = 0; j < sizeY; j++) {
			setPixel(i, j, curX2);
		}
	}
	
	newImage("sy", "32-bit", sizeX, sizeY, 1);
	curY = newArray(sizeY);
	for (i = 0; i < sizeX; i++) {
		for (j = 0; j < sizeY; j++) {
			selectWindow(inputImg);
			curY[j] = curY[j]+getPixel(i,j);
			
			selectWindow("sy");
			setPixel(i, j, curY[j]);
		}
	}
	
	newImage("sxy", "32-bit", sizeX, sizeY, 1);
	curXY = newArray(sizeY);
	for (i = 0; i < sizeX; i++) {
		for (j = 0; j < sizeY; j++) {
			selectWindow(inputImg);
			curXY[j] = curXY[j]+getPixel(i,j)*i;
			
			selectWindow("sxy");
			setPixel(i, j, curXY[j]);
		}
	}

	a = newArray(sizeY);
	b = newArray(sizeY);
	for (j = 0; j < sizeY; j++) {
		selectWindow("sxy");
		sxy = getPixel(sizeX-1,j);

		selectWindow("sx");
		sx = getPixel(sizeX-1,j);

		selectWindow("sx2");
		sx2 = getPixel(sizeX-1,j);

		selectWindow("sy");
		sy = getPixel(sizeX-1,j);

		a[j] = ( sizeX * sxy - sx*sy)/(sizeX *sx2 - sx*sx);
		b[j] = (sy - a[j] * sx)/ sizeX;
	}

	newImage(linTrend, "32-bit", sizeX, sizeY, 1);
	for (i = 0; i < sizeX; i++) {
		for (j = 0; j < sizeY; j++) {
			setPixel(i,j, i*a[j]+b[j]);	
		}
	}
	selectWindow("x");
	close();
	selectWindow("sx");
	close();
	selectWindow("sx2");
	close();
	selectWindow("sy");
	close();
	selectWindow("sxy");
	close();
}
// performs measurements of intensity on the whole image
// savePath should just be a directory
function wholeImgIntensityMeasurementAllChannels(savePath,inputWindowName){
	selectWindow(inputWindowName);
	
	// generate a mask that encompasses the entire image, to be used for measurements
	run("Duplicate...", "duplicate channels=1");
	rename("tmpDuplicate1");
	selectWindow("tmpDuplicate1");
	setThreshold(0, 65535); 
	setOption("BlackBackground", true);
	run("Convert to Mask", "method=Default background=Light black");

	selectWindow(inputWindowName);
	getDimensions(sizeX, sizeY, C, sizeZ, F);
	for (i = 1; i <= C; i++) {
	    selectWindow(inputWindowName);
	    run("Duplicate...", "duplicate channels="+i);
		rename("tmpDuplicate2");
		run("Intensity Measurements 2D/3D", "input=tmpDuplicate2 labels=tmpDuplicate1"+
			" mean stddev max min median mode skewness kurtosis numberofvoxels volume neighborsmean"+
			" neighborsstddev neighborsmax neighborsmin neighborsmedian neighborsmode"+
			" neighborsskewness neighborskurtosis");
		saveAs("tmpDuplicate2-intensity-measurements",savePath+"C"+i+"_wholeImgInt.csv");
		run("Close");
		
		selectWindow("tmpDuplicate2");
		close();
	}
	print("whole image intensity file saved");
	selectWindow("tmpDuplicate1");
	close();
}

// takes an image (inputWindowName), duplicates the channel with nucleoplasm mask, 
// then measures 1) intensity etc and 2) geometry on all Channels
// and saves the resulting tables in the folder savePath using names like 
// C1_rootName_plasmInt.csv, C2_rootName_plasmInt.csv, etc for intensity features
// single file rootName-nucleoplasmGeom.csv for geometry features 
function nucleoplasmIntensityAndGeometryMeasurementAllChannels(savePath,rootName,inputWindowName,maskChannel){
	selectWindow(inputWindowName);
	run("Duplicate...", "duplicate channels="+maskChannel);
	rename("tmpDuplicate1");

	run("Analyze Regions 3D", "voxel_count volume surface_area mean_breadth sphericity"+
			" euler_number bounding_box centroid equivalent_ellipsoid ellipsoid_elongations"+
			" max._inscribed surface_area_method=[Crofton (13 dirs.)] euler_connectivity=6");

	saveAs("Results",savePath+rootName+"_plasmGeom.csv");
	run("Close");
	
	selectWindow(inputWindowName);
	getDimensions(sizeX, sizeY, C, sizeZ, F);
	for (i = 1; i <= C; i++) {
	    selectWindow(inputWindowName);
	    run("Duplicate...", "duplicate channels="+i);
		rename("tmpDuplicate2");
		run("Intensity Measurements 2D/3D", "input=tmpDuplicate2 labels=tmpDuplicate1"+ 
			" mean stddev max min median mode skewness kurtosis numberofvoxels volume"+
			" neighborsmean neighborsstddev neighborsmax neighborsmin neighborsmedian"+
			" neighborsmode neighborsskewness neighborskurtosis");
		
		saveAs("tmpDuplicate2-intensity-measurements",savePath+"C"+i+"_"+rootName+"_plasmInt.csv");
		run("Close");
		selectWindow("tmpDuplicate2");
		close();
	}
	
	print("Nuclei Intensity and Geometry results saved");
	selectWindow("tmpDuplicate1");
	close();
}

function nucleiGeometryMeasurement(inputWindowName,maskChannel,saveFileName){
	selectWindow(inputWindowName);
	run("Duplicate...", "duplicate channels="+maskChannel);
	rename("tmpDuplicate1");

	run("Analyze Regions 3D", "voxel_count volume surface_area mean_breadth sphericity"+
			" euler_number bounding_box centroid equivalent_ellipsoid ellipsoid_elongations"+
			" max._inscribed surface_area_method=[Crofton (13 dirs.)] euler_connectivity=6");

	saveAs("Results",saveFileName);
	run("Close");
	selectWindow("tmpDuplicate1");
	close();
}

// takes an image (inputWindowName), duplicates the channel with masks, then measures 1) intensity/neighbors etc and 2) geometry, centroid etc on all Channels
// and saves the resulting tables in the folder savePath using names like 
// C1_nucInt.csv, C2_nucInt.csv, etc for intensity features
// single file nucGeom.csv for geometry features 
function nucleiIntensityAndGeometryMeasurementAllChannels(savePath,inputWindowName,maskChannel){
	selectWindow(inputWindowName);
	run("Duplicate...", "duplicate channels="+maskChannel);
	rename("tmpDuplicate1");

	run("Analyze Regions 3D", "voxel_count volume surface_area mean_breadth sphericity"+
			" euler_number bounding_box centroid equivalent_ellipsoid ellipsoid_elongations"+
			" max._inscribed surface_area_method=[Crofton (13 dirs.)] euler_connectivity=6");

	saveAs("Results",savePath+"nucGeom.csv");
	run("Close");
	
	selectWindow(inputWindowName);
	getDimensions(sizeX, sizeY, C, sizeZ, F);
	for (i = 1; i <= C; i++) {
	    selectWindow(inputWindowName);
	    run("Duplicate...", "duplicate channels="+i);
		rename("tmpDuplicate2");
		run("Intensity Measurements 2D/3D", "input=tmpDuplicate2 labels=tmpDuplicate1"+ 
			" mean stddev max min median mode skewness kurtosis numberofvoxels volume"+
			" neighborsmean neighborsstddev neighborsmax neighborsmin neighborsmedian"+
			" neighborsmode neighborsskewness neighborskurtosis");
		
		saveAs("tmpDuplicate2-intensity-measurements",savePath+"C"+i+"_nucInt.csv");
		run("Close");
		
		selectWindow("tmpDuplicate2");
		close();
	}
	
	print("Nuclei Intensity and Geometry results saved");
	selectWindow("tmpDuplicate1");
	close();
}

// takes an image (inputWindowName) generates a global mask for the entire egg chamber
// using the intensity in measurementChannel as a basis (and using some filtering/thresholding), 
// then measures intensity/neighbors etc in all channels using the new mask as an ROI
// and saves the resulting tables in the folder savePath with names C1_eggChamberInt.csv, C2_eggChamberInt.csv etc
function eggChamberIntensityMeasurementAllChannels(savePath,inputWindowName,measurementChannel){
	selectWindow(inputWindowName);
	
	// generate a mask that encompasses the egg chamber, to be used for measurements
	selectWindow(inputWindowName);
	run("Duplicate...", "duplicate channels="+measurementChannel);
	rename("tmpDuplicate1");
	selectWindow("tmpDuplicate1");
	run("Median...", "radius=16 stack");
	run("Auto Threshold", "method=Default white stack");
	setAutoThreshold("Default");
	run("Threshold...");
	setThreshold(255, 255);
	setOption("BlackBackground", true);
	run("Convert to Mask", "method=Default background=Light black");
	
	selectWindow(inputWindowName);
	getDimensions(sizeX, sizeY, C, sizeZ, F);
	for (i = 1; i <= C; i++) {
	    selectWindow(inputWindowName);
	    run("Duplicate...", "duplicate channels="+i);
		rename("tmpDuplicate2");
		
		run("Intensity Measurements 2D/3D", "input=tmpDuplicate2 labels=tmpDuplicate1"+
			" mean stddev max min median mode skewness kurtosis numberofvoxels volume"+
			" neighborsmean neighborsstddev neighborsmax neighborsmin neighborsmedian"+
			" neighborsmode neighborsskewness neighborskurtosis");
			
		saveAs("tmpDuplicate2-intensity-measurements",savePath+"C"+i+"_eggChamberInt.csv");
		run("Close");
		
		selectWindow("tmpDuplicate2");
		close();
	}

	print("intensity over mask file saved");
	selectWindow("tmpDuplicate1");
	close();
}

function saveParametersToLogFile(originalImgTitle,saveDir,
	sizeX, sizeY, C, sizeZ,
	hoechstChannel,pol2Channel,NucleusQuantChannelOfInterest,fftSmall,fftLarge,
	border,nMaxObjectVolume,SurfaceToVolumeRatioThreshold,
	MaxOutputObject,threshFactor,MedianFilterRadiusClusters,
	MedianFilterRadiusBackground,nucleiFound){

	f = File.open(saveDir+"analysisParameters.txt");
   	// use d2s() function (double to string) to specify decimal places 
   	//for (i=0; i<=2*PI; i+=0.01)
    //  print(f, d2s(i,6) + "  \t" + d2s(sin(i),6) + " \t" + d2s(cos(i),6));
    print(f, "****** Input image: \r\n");
    print(f,"Title of input image: "+ originalImgTitle + "\r\n");
    print(f,"Input image dimensions : "+ sizeX +" (X), "+sizeY+" (Y), "+ sizeZ + " (Z), " +C+ " (Channels).\r\n");
    print(f," \r\n");
    
    print(f,"****** Nucleus Detection Settings:\r\n");
    print(f, "hoechstChannel: " + hoechstChannel+ "\r\n");
    print(f, "fftSmall: "+ fftSmall+ "\r\n");
    print(f, "fftLarge: "+ fftLarge+ "\r\n");
	print(f, "border: "+ border+ "\r\n");
	print(f, "nMaxObjectVolume: "+ nMaxObjectVolume+ "\r\n");
	print(f, "SurfaceToVolumeRatioThreshold: "+ SurfaceToVolumeRatioThreshold+ "\r\n");
	print(f, "MaxOutputObject: "+ MaxOutputObject+ "\r\n");
	print(f, "nucleiFound: "+ nucleiFound+ "\r\n");
	print(f, "NucleusQuantChannelOfInterest: "+ NucleusQuantChannelOfInterest+ "\r\n");
    print(f," \r\n");
	
	print(f,"****** Cluster Detection Settings:\r\n");
	print(f, "pol2Channel: "+ pol2Channel+ "\r\n");
	print(f, "threshFactor: "+ threshFactor+ "\r\n");
	print(f, "MedianFilterRadiusClusters: "+ MedianFilterRadiusClusters+ "\r\n");
	print(f, "MedianFilterRadiusBackground: "+ MedianFilterRadiusBackground+ "\r\n");
	print(f," \r\n");
	
}

function segmentNuclei3D(originalImgTitle,initiallySegmentedNuclei,nucleiChannel,fftSmall,fftLarge){
	// duplicate hoechst channel
	selectWindow(originalImgTitle);
	run("Duplicate...", "title=hoechst duplicate channels="+nucleiChannel);
	getDimensions(sizeX, sizeY, C, sizeZ, F);
	
	setAutoThreshold("Default dark stack");
	run("Make Binary", "method=Default background=Dark black");
	run("Fill Holes", "stack");
	run("Morphological Filters (3D)", "operation=Erosion element=Cube x-radius=1 y-radius=1 z-radius=1");
	run("Morphological Filters (3D)", "operation=Erosion element=Cube x-radius=1 y-radius=1 z-radius=1");
	binaryImgTitle = "filteredMasks";
	rename(binaryImgTitle);
	
	run("Chamfer Distance Map 3D", "distances=[Svensson <3,4,5,7>] output=[16 bits] normalize");
	run("Bandpass Filter...", "filter_large="+fftLarge+" filter_small="+fftSmall+" suppress=None tolerance=5 process");
	run("Invert", "stack");
	setMinAndMax(0, 65535);
	run("8-bit");
	invertedImgTitle = getTitle();
	run("Classic Watershed", "input="+invertedImgTitle+" mask="+binaryImgTitle+" use min=0 max=255");
	selectWindow("watershed");
	run("16-bit");
	run("Label Size Filtering", "operation=Greater_Than size=1000");
	run("Morphological Filters (3D)", "operation=Dilation element=Ball x-radius=4 y-radius=4 z-radius=4");
	run("glasbey on dark");
	rename(initiallySegmentedNuclei);

	// close intermediates
	selectWindow("watershed");
	close();
	selectWindow("watershed-sizeFilt");
	close();
	selectWindow("hoechst-Erosion");
	close();
	selectWindow("hoechst");
	close();
	selectWindow(binaryImgTitle);
	close();
	selectWindow(binaryImgTitle+"-dist");
	close();
}

// extracts nuclei from hyperstack originalImgTitle based on dapi/hoechst signal expected to be in channel nucleiChannel
// output image is called initiallySegmentedNuclei
// this segmentation step gets all nuclei well usually but retains follicle cells and can generate clumped/oversegmented nuclei
function segmentNuclei(originalImgTitle,initiallySegmentedNuclei,nucleiChannel,fftSmall,fftLarge){
	// duplicate pol II channel
	selectWindow(originalImgTitle);
	run("Duplicate...", "title=hoechst duplicate channels="+nucleiChannel);
	getDimensions(sizeX, sizeY, C, sizeZ, F);
	
	// apply autothreshold
	run("Auto Threshold", "method=Default white show stack");
	run("Threshold...");
	run("Options...", "iterations=1 count=1 black do=Nothing");
	
	// convert into a binary mask
	run("Convert to Mask", "method=Default background=Dark calculate black");
	run("Fill Holes", "stack");
	binaryImgTitle = "filteredMasks";
	rename(binaryImgTitle);

	// Use watershed based on a champfer distance transform to split artefactually merged nuclei
	// Chamfer distance 3D Svensson 3457, 16 bit output. FFT bandpass 30/2000. Invert. Watershed using masks.
	run("Chamfer Distance Map 3D", "distances=[Svensson <3,4,5,7>] output=[16 bits] normalize");
	run("Bandpass Filter...", "filter_large="+fftLarge+" filter_small="+fftSmall+" suppress=None tolerance=5 process");
	run("Invert", "stack");
	invertedImgTitle = getTitle();
	run("Classic Watershed", "input="+invertedImgTitle+" mask="+binaryImgTitle+" use min=0 max=255");
	run("glasbey on dark");
	selectWindow("watershed");
	run("16-bit");
	rename(initiallySegmentedNuclei);

	// close intermediates
	selectWindow(binaryImgTitle);
	close();
	selectWindow(binaryImgTitle+"-dist");
	close();

}

// this function loops through all nuclei objects (defined by masks in the last color channel of the hyperstack inputImgTitle)
// and generates one stack per nucleus (called "croppedNucleus"+i+"wSeg" for nucleus i)
// that retains all the color channels of the input stack; 
// the last channel only contains the mask corresponding to the nucleus of interest (other nuclei masks are erased)
// border is the padding in pixels around each cropped nucleus
function cropNuclei(inputImgTitle,border,saveStacks){
	selectWindow(inputImgTitle);
	getDimensions(sizeX, sizeY, C, sizeZ, F);
	segmentationChannel = C;
	run("Duplicate...", "duplicate channels="+C);
	rename("duplicateNucleiID");

	selectWindow(inputImgTitle);
	C2 = C-1;
	run("Duplicate...", "duplicate channels=1-"+C2);
	rename("dataStack");
	
	selectWindow("duplicateNucleiID");
	run("Z Project...", "projection=[Max Intensity]");
	getStatistics(area, mean, min, max, std);
	nucleiFound = max;
	print("number of nuclei =" + nucleiFound);
	for (i = 1; i < nucleiFound+1; i++) {
		getLabelBoundingBox3("duplicateNucleiID","dataStack","croppedNucleus"+i+"wSeg",i,border);

		// save image with masks
		selectWindow("croppedNucleus"+i+"wSeg");
		if (saveStacks == 1){
			save(saveDir+"croppedNucleus"+i+"wSeg_masks.tif");	
		}
	}
	// close intermediate
	selectWindow("duplicateNucleiID");
	close();
	selectWindow("dataStack");
	close();
	selectWindow("MAX_duplicateNucleiID");
	close();
	
}

// dialog box to input parameters
function inputParameters(){
	Dialog.create("Segmentation Parameters");
	
	Dialog.addMessage("******************* Nucleus Segmentation Module");
	Dialog.addNumber("Hoechst color channel:", hoechstChannel);	
	Dialog.addNumber("Whole-nucleus quantification color channel:", NucleusQuantChannelOfInterest);	
	Dialog.addNumber("max size of small features excluded by bandpass filter to segment nuclei: :", fftSmall);
	Dialog.addNumber("min size of large features excluded by bandpass filter to segment nuclei: ", fftLarge);
	Dialog.addNumber("padding in pixels around cropped nuclei:", border);
	Dialog.addNumber("number of candidate nuclei to vet:",nMaxObjectVolume);
	Dialog.addNumber("maximum surface to volume ratio of nuclei:",SurfaceToVolumeRatioThreshold);
	Dialog.addNumber("maximum number of segmented nuclei to retain:",MaxOutputObject);
	
	Dialog.addMessage("******************* Pol II cluster detection Module");
	Dialog.addNumber("PolII color channel:", pol2Channel);
	Dialog.addNumber("Threshold Factor used to detect clusters:", threshFactor);
	Dialog.addNumber("radius of Median filter to smooth Pol II signal:", MedianFilterRadiusClusters);
	Dialog.addNumber("radius of Median filter to generate background image:", MedianFilterRadiusBackground);
	Dialog.show();

	hoechstChannel = Dialog.getNumber();
	NucleusQuantChannelOfInterest = Dialog.getNumber();
	fftSmall = Dialog.getNumber();
	fftLarge = Dialog.getNumber();
	border = Dialog.getNumber();
	nMaxObjectVolume=Dialog.getNumber();
	SurfaceToVolumeRatioThreshold=Dialog.getNumber();
	MaxOutputObject=Dialog.getNumber();
	
	pol2channel = Dialog.getNumber();
	threshFactor = Dialog.getNumber();
	MedianFilterRadiusClusters = Dialog.getNumber();
	MedianFilterRadiusBackground = Dialog.getNumber();
	
	print("*******************************");
	print("Hoechst color channel: "+hoechstChannel);
	print("Whole-nucleus quantification color channel: "+NucleusQuantChannelOfInterest);	
	print("max size of small features excluded by bandpass filter to segment nuclei: "+fftSmall);
	print("min size of large features excluded by bandpass filter to segment nuclei: "+fftLarge);
	print("padding in pixels around cropped nuclei: ", border);
	print("number of candidate nuclei to vet:",nMaxObjectVolume);
	print("maximum surface to volume ratio of nuclei:",SurfaceToVolumeRatioThreshold);
	print("maximum number of segmented nuclei to retain:",MaxOutputObject);
	print("  ");
	print("polII channel: "+ pol2Channel);
	print("Threshold Factor used to detect clusters: "+threshFactor);
	print("radius of Median filter to smooth Pol II signal: "+MedianFilterRadiusClusters);
	print("radius of Median filter to generate background image: "+MedianFilterRadiusBackground);
}

// finds the rectangular bounding box around a 3D object labeled with the value label in the input stack inputObjectIDsTitle
// generates a rectangular ROI around the object including a padding radius of border pixels around it.
// crops the data stack inputImgDataTitle accroding to that ROI
function getLabelBoundingBox3(inputObjectIDsTitle,inputImgDataTitle,outputImgTitle,label,border){
	selectWindow(inputObjectIDsTitle);
	run("Select All");
	
	// duplicate nuclei ID image
	run("Duplicate...", "duplicate");
	
	// threshold stack to keep only current nucleus
	setThreshold(label, label);
	run("Convert to Mask", "method=Default background=Dark black");
	rename("isolatedNucleus"+label);
	
	// image size
	getDimensions(sizeX, sizeY, C, sizeZ, F);

	// find the lowest plane holding the nucleus (zmin) and the highest (zmax)
	zmin = sizeZ;
	zmax = 0;
	for (z = 1; z <= sizeZ; z++)
	{
		Stack.setPosition(1, z, 1);
		getStatistics(area, mean, min, max, std, histogram);
		if(max == 255){
			if (zmin>z) {
				zmin=z;
			}
			if (zmax<z) {
				zmax=z;
			}
		}
	}
	print("zmin = "+zmin+"; zmax = "+zmax);

	// add border
	if((zmin-border)<1){
		zmin = 1;
	}else {
		zmin = zmin-border;
	}

	if((zmax+border)>sizeZ){
		zmax = sizeZ;
	}else {
		zmax = zmax+border;
	}
	print("(with border) zmin = "+zmin+"; zmax = "+zmax);
	
	// find xy bounding box
	run("Z Project...", "projection=[Max Intensity]");
	// add padding in xy by running a series of border dilations
	for (i = 0; i < border; i++) {
		run("Dilate");
	}
	roiManager("reset");
	setThreshold(100, 255);
	run("Create Selection");
	run("To Bounding Box");
	roiManager("Add");

	// select the original data stack and duplicate a cropped version
	selectWindow(inputImgDataTitle);
	roiManager("Select", 0);
	run("Duplicate...", "duplicate slices="+zmin+"-"+zmax);
	rename("croppedNucleus"+label);

	// cropped image size
	getDimensions(w, h, c, z, f);
	
	//convert the thresholded nucleus image back to its original value
	selectWindow("isolatedNucleus"+label);
	run("16-bit");
	run("Multiply...", "value="+label+" stack");
	run("Divide...", "value=255.000 stack");
	roiManager("Select", 0);
	run("Duplicate...", "duplicate range="+zmin+"-"+zmax);
	rename("isolatedCroppedNucleus"+label);
	
	// create cropped image holding initial data + nucleus segmentation
	addChannelToImg("croppedNucleus"+label,"isolatedCroppedNucleus"+label,outputImgTitle,0);

	// close intermediates
	selectWindow("isolatedNucleus"+label);
	close();
	selectWindow("MAX_isolatedNucleus"+label);
	close();
}

// in order to sort out nurse cells nuclei (huge) from follicle cells nuclei (small)
// and to avoid grossly missegmented objects, this function loops through the largest nMaxObjectVolume nuclei 
// and selects the largest MaxOutputObject ones that have a surface:volume ratio lower than SurfaceToVolumeRatioThreshold
// nMaxObjectVolume (default 20), MaxOutputObject (15), and SurfaceToVolumeRatioThreshold (1.2) should be global variables
// that are required by the function.
function selectCorrectlySegmentedNuclei(inputImageTitle,outputImageTitle,
	nMaxObjectVol,SurfaceToVolumeRatioThresh,MaxOutputObj){
	
	selectWindow(inputImageTitle);

	// collect table of object geometric features
	run("Analyze Regions 3D", "volume surface_area mean_breadth sphericity euler_number" 
	+" bounding_box centroid equivalent_ellipsoid ellipsoid_elongations max._inscribed"
	+" surface_area_method=[Crofton (13 dirs.)] euler_connectivity=26");

	// rename the morpholibj output table so ImageJ recognizes it as a Results table
	// the extension of the filename is not transfered to the morpholibJ table name
	if(indexOf(inputImageTitle,'.')>0){
		imgNameWOExt = inputImageTitle.substring(0,indexOf(inputImageTitle,'.'));
	}else{
		imgNameWOExt = inputImageTitle;
	}
	print(imgNameWOExt);
	Table.rename(imgNameWOExt+"-morpho", "Results");

	// ranking the  Results table by decreasing object Volume
	print("sorting through "+nResults+" objects...");
	Table.sort("Volume");
	n = Table.size;
	Table.setColumn("idx", Array.reverse(Array.getSequence(n)));
	Table.sort("idx");
	Table.deleteColumn("idx");

	// going through nuclei with top 20 Volume values 
	// and select the ones that satisfy the surface to volume ratio threshold
	volArray = newArray(nMaxObjectVol);
	surArray = newArray(nMaxObjectVol);
	LabelArray = newArray(nMaxObjectVol);
	
	counter=0;
	LabelString="";
	nMaxObjectVol = minOf(nMaxObjectVol,nResults); 
	for (i=0; i<nMaxObjectVolume; i++){
 	 volArray[i] = getResult("Volume",i);
 	 surArray[i] = getResult("SurfaceArea",i)/volArray[i];
 	 LabelArray[i] = getResultString("Label",i);
 	 if ((surArray[i]<SurfaceToVolumeRatioThresh) && (counter<MaxOutputObj)){
 	 	counter=counter+1;
		print("****");
 	 	print("Selected object # " + counter);
 	 	print("Object label "+ LabelArray[i]);
 	 	print("surface to Volume ratio = "+ surArray[i]);
 	 	LabelString=LabelString+LabelArray[i]+",";
 	 	print(" ");
 	 }
	}
	LabelString = LabelString.substring(0,LabelString.length-1);
	print("Selected "+ counter +" objects with following labels: "+LabelString);

	// generate a new image with only the selected objects
	run("Select Label(s)", "label(s)="+LabelString); 
	labelImg = getTitle();
	
	run("Connected Components Labeling", "connectivity=26 type=[16 bits]");
	run("glasbey on dark");
	rename(outputImageTitle);
	selectWindow(labelImg);
	close();
	return nMaxObjectVol;
}

// appends an extra color channel (channelSource) to a hyperstack (imgSource) and renames the result newImgName 
function addChannelToImg(imgSource,channelSource,newImgName,keepSourceImgs){

	selectWindow(imgSource);
	b1 = bitDepth();
	selectWindow(channelSource);
	b2 = bitDepth();
	if ((b1 == 32) | (b2 == 32)){
		selectWindow(imgSource);
		run("32-bit");
		selectWindow(channelSource);
		run("32-bit");
	}
	
	
	selectWindow(imgSource);
	b1 = bitDepth();
	if(keepSourceImgs == 1){
		keepString = " keep";
	}else{
		keepString = "";
	}
	
	selectWindow(imgSource);
	getDimensions(w, h, c, z, f);
	if(c==1){
		argumentString = "c1="+imgSource+" c2="+channelSource+" create"+keepString;	
	}else{
		run("Split Channels");
		argumentString0 = "";
		for(i=1;i<=c;i++){
			argumentString0 = argumentString0 + "c"+i+"=C"+i+"-"+imgSource+" ";
		}
		i = c+1;
		argumentString1 = argumentString0 + "c"+i+"="+channelSource+" create"+keepString;
		argumentString0 = argumentString0 + " create";
		print(argumentString0);
		print(argumentString1);
	}
	run("Merge Channels...", argumentString1);
	rename(newImgName);
	if(keepSourceImgs == 1){
		run("Merge Channels...", argumentString0);
		rename(imgSource);
	}
	
}

// takes curImg hyperstack as input, using the nucleoplasm mask stack
// at each slice it subtractes the average nucleoplasm value to the whole plane
function subtractBackground32bit3D(curImg,maskedNucleoplasmImgTitle,imgBgCorr){
	selectWindow(curImg);
	getDimensions(w, h, c, nzs, f);
	
	// compute mean in the nucleoplasm mask in each channel
	plasmMean = newArray(c);
	for (ic = 1; ic <= c; ic++) {
		run("Duplicate...", "duplicate channels="+ic);
		rename("curChannel");
		run("Intensity Measurements 2D/3D", "input=curChannel labels="+maskedNucleoplasmImgTitle+" mean");

		// rename the morpholibj output table so ImageJ recognizes it as a Results table
		// the extension of the filename is not transfered to the morpholibJ table name
		Table.rename("curChannel-intensity-measurements", "Results");
	
		// extract  mean
		plasmMean[ic-1] = getResult("Mean",0);
		selectWindow("curChannel");
		close();
	}
	
	//duplicate the image
	selectWindow(curImg);
	run("Duplicate...", "duplicate");
	rename(imgBgCorr);
	run("32-bit");
	
	// subtract background from duplicate in each channel
	// only goes to c-1 because the last channel is the nucleus segmentation result
	selectWindow(imgBgCorr);
	run("Select All");
	for(ic=0;ic<c-1;ic++){
		for (izs = 0; izs < nzs; izs++) {
			Stack.setPosition(ic+1, izs+1, 1);
			run("Subtract...", "value="+plasmMean[ic]+" slice");
		}
	}
}


// takes curImg hyperstack as input, using the nucleoplasm mask stack
// at each slice it subtractes the average nucleoplasm value to the whole plane
function subtractBackground32bit(curImg,maskedNucleoplasmImgTitle,imgBgCorr){
	//compute the number of channels of the input curImg
	selectWindow(curImg);
	run("Duplicate...", "duplicate");
	rename(imgBgCorr);
	run("32-bit");
	getDimensions(w, h, curImgChannels, nzs, f);
	
	//duplicate nucleoplasm mask - invert because somehow the Create Selection uses the inverse of the mask (wtf?) 
	selectWindow(maskedNucleoplasmImgTitle);
	run("Duplicate...", "duplicate channels=1");
	rename("workingNucleoplasm");
	
	// generate placeholder images 
	getDimensions(w, h, c, nzs, f);
	
	// create an array that will hold the mean nucleoplasm intensity
	meanChannels = newArray(curImgChannels); 
	for (i=0; i<meanChannels.length; i++){
      meanChannels[i] = 0;
	}
	
	// run through slices 
	for (izs = 0; izs < nzs; izs++) {
		
		roiManager("reset");
		selectWindow("workingNucleoplasm");
		Stack.setPosition(1, izs+1, 1);
		
		// first we make sure that the nucleoplasm mask is present in the current slice, 
		// i.e. min = 0 and max = 255 intensities in the mask stack.
		getStatistics(area, mean, min, max, std); 
		if (verbose){
			print("slice "+izs+"; minInvMask = "+min+"; maxInvMask = "+max);
		}
		
		// if mask is present, create a selection around it
		flag = 0;
		if ((min==0) && (max == 255)){
			flag = 1;
			setThreshold(254, 255);
			run("Create Selection");
			roiManager("Add");
		}

		//in each channel, compute the mean intensity within the nucleoplasm mask in the current slice
		// and subtract it from the whole slice.
		selectWindow(imgBgCorr);
		for(c=0;c<curImgChannels-1;c++){
			Stack.setPosition(c+1, izs+1, 1);
			if(flag == 1){
				roiManager("Select", 0);
				getStatistics(area, mean, min, max, std);
				print("slice "+izs+"; channel "+c+"; meann plasm = "+mean
					+"; mask area "+area+"; min plasm = "+min+"; max plasm = "+max);
				meanChannels[c] = mean;
			}
			else{
				meanChannels[c] = 0;
			}
			run("Select All");
			run("Subtract...", "value="+meanChannels[c]+" slice");
		}
	}
	// close intermediate
	selectWindow("workingNucleoplasm");
	close();
}

function computeClusterStats(dataImg,labelImg,saveDir,nucleusNumber,csvSuffix){
	
	selectWindow(dataImg);
	getDimensions(w, h, c, nzs, f);
	for (i = 1; i <= c; i++) {
		selectWindow(dataImg);
		run("Duplicate...", "duplicate channels="+i);
		rename("tmpChannel");
		run("Intensity Measurements 2D/3D", "input=tmpChannel labels="
			+labelImg+" mean stddev max min median mode skewness kurtosis numberofvoxels volume");
		saveAs("Results", saveDir+"C"+i+"_nuc"+nucleusNumber +csvSuffix);
		run("Close");
		selectWindow("tmpChannel");
		close();
	}
}

// from a hypertack curImg, containing a channel with Pol II data (pol2channel),
// detects Pol II clusters as follows and saves a mask stack of the detected clusters under the title maskedClustersImgTitle.
// cluster detection proceeds as follows:
// 1) filter out salt and pepper noise in Pol II channel (median filtering with radius MedFiltRadiusCluster)
// 2) subtract the nuclear background from the filtered Pol II channel (this requires a stack holding a mask of the nucleoplasm as an input, maskedNucleoplasmImgTitle)
// 3) detect clusters as regions where intensity is threshF times the std of the intensity of the background corrected image.
// #2) and #3) are performed slice by slice to accound for loss of signal with increasing depth.
// Because nurse cells nuclei have the background is computed by:
// 2.1 creating image that is 0 outside nucleoplasm, smoothed pol2 signal inside
// 2.2 fill in the holes of the image in 2.1 with the average intensity in the nucleoplasm
function detectClusters(curImg,maskedClustersImgTitle,pol2channel,MedFiltRadiusCluster,MedFiltRadiusBg,maskedNucleoplasmImgTitle,threshF){

	// duplicate pol2 channel and median filter to remove salt and pepper noise
	selectWindow(curImg);
	run("Duplicate...", "duplicate channels="+pol2Channel);
	run("Median...", "radius="+MedFiltRadiusCluster+" stack");
	rename("pol2median");

	//duplicate nucleoplasm mask
	selectWindow(maskedNucleoplasmImgTitle);
	run("Duplicate...", "duplicate channels=1");
	rename("plasmMask");

	// generate placeholder images 
	getDimensions(w, h, c, nzs, f);
	newImage("clusterMasks", "8-bit Black", w, h, nzs);
	newImage("bgCorrImg", "32-bit Black", w, h, nzs);

	// run through slices 
	for (izs = 0; izs < nzs; izs++) {
	//for (izs = 24; izs < 25; izs++) {
	
		roiManager("reset");
		selectWindow("plasmMask");
		Stack.setPosition(1, izs+1, 1);
		getStatistics(area, mean, min, max, std);

		if (verbose){
			print("slice "+izs+"; minPlasmMask = "+min+"; maxPlasmMask = "+max);
		}
		
		if ((min==0) && (max == 255)){
			// collect avg and std of smoothed pol2 signal
			setThreshold(254, 255);
			run("Create Selection");
			roiManager("Add");
			selectWindow("pol2median");
			Stack.setPosition(1, izs+1, 1);
			roiManager("Select", 0);
			getStatistics(area, mean, min, max, std);
			if (verbose){
				print("slice "+izs+"; area = "+area+"; mean = "+mean+"; std = "+std);
			}
			
			// duplicate smoothed pol2
			run("Select None");
			run("Duplicate...", " ");
			rename("tempPol2");
	
			//duplicate nucleoplasm mask
			selectWindow("plasmMask");
			Stack.setPosition(1, izs+1, 1);
			run("Select None");
			run("Duplicate...", " ");
			run("Divide...", "value=255.000 stack");
			setMinAndMax(0, 65535);
			run("16-bit");
			rename("tempMask");

			// create image that is 0 outside nucleoplasm, smoothed pol2 signal inside
			imageCalculator("Multiply create stack", "tempPol2","tempMask");
			rename("insideNucleoplasm");
	
			// create image that is 0 inside nucleoplasm, <average smoothed pol2 signal within nucleoplasm> outside
			selectWindow("tempMask");
			run("Multiply...", "value="+mean+" stack");
			rename("outsideNucleoplasm");
	
			// sum both images above to generate an image where the holes in the nucleus have the average nucleoplasm intensity
			imageCalculator("Add", "insideNucleoplasm","outsideNucleoplasm");
			rename("filledNucleoplasm");
	
			// median-filter the image just generated and subtract it to remove local background
			selectWindow("filledNucleoplasm");
			run("Duplicate...", "duplicate");
			run("Median...", "radius="+MedFiltRadiusBg);
			rename("medFilteredBackground");
			imageCalculator("Subtract create 32-bit stack", "filledNucleoplasm","medFilteredBackground");
			rename("backgroundSubstracted");
	
			// copy background subtracted image in stack
			run("Select All");
			setPasteMode("Copy");
			run("Copy");
			selectWindow("bgCorrImg");
			Stack.setPosition(1, izs+1, 1);
			setPasteMode("Copy");
			run("Paste");
			
			// compute std of background corrected image
			roiManager("reset")
			selectWindow("plasmMask");
			Stack.setPosition(1, izs+1, 1);
			setThreshold(254, 255);
			run("Create Selection");
			roiManager("Add");
			selectWindow("backgroundSubstracted");
			roiManager("Select", 0);
			
			// set threshold to detect clusters
			getStatistics(area, mean, min, max, std);
			t = threshF*std;
			print("slice "+izs+"; background-corrected std = "+std+ "; threshold = "+t);
			setThreshold(t, 65535);
			run("Convert to Mask", "method=Default background=Dark black");
			setPasteMode("Copy");
			run("Copy");
			selectWindow("clusterMasks");
			Stack.setPosition(1, izs+1, 1);
			setPasteMode("Copy");
			run("Paste");

			// close intermediates
			selectWindow("backgroundSubstracted");
			close();
			selectWindow("tempPol2");
			close();
			selectWindow("filledNucleoplasm");
			close();
			selectWindow("medFilteredBackground");
			close();
			selectWindow("outsideNucleoplasm");
			close();
		}
	}
	selectWindow("clusterMasks");
	// run connected components labeling so that each nucleus gets an individual ID
	run("Connected Components Labeling", "connectivity=6 type=[16 bits]");
	run("glasbey on dark");
	rename(maskedClustersImgTitle);
	
	// close intermediate
	selectWindow("clusterMasks");
	close();
	selectWindow("plasmMask");
	close();
	selectWindow("bgCorrImg");
	close();
	selectWindow("pol2median");
	close();
}

// starts from an image curImg where the Pol II signal is in channel pol2ChannelNum
// threshold the nuclei based on Pol II signal, then
// duplicate last channel holding nuclei IDs
function segmentNucleoplasm(curImg,pol2ChannelNum,outputImgName){
	
	selectWindow(curImg);
	getDimensions(w, h, c, nzs, f);
	
	// gnerate a nucleus mask image: threshold nuclei IDs so that all nuclei are white, background is black
	run("Duplicate...", "duplicate channels="+c);
	setThreshold(1, 65535);
	run("Convert to Mask", "method=Default background=Dark black");
	run("16-bit");
	run("Divide...", "value=255.000 stack"); // set white to 1
	rename("masksBinary");

	// duplicate pol2 and multiply it with the [0,1] binary nuclei mask image
	selectWindow(curImg);
	run("Duplicate...", "duplicate channels="+pol2ChannelNum);
	rename("pol2tmp");
	imageCalculator("Multiply create stack", "pol2tmp", "masksBinary");
	rename("maskedNucleusIntensity");
	
	// close intermediates
	selectWindow("pol2tmp");
	close();
	selectWindow("masksBinary");
	close();
	
	// make a 0/255 mask for the nucleoplasm alone using autothresholding
	selectWindow("maskedNucleusIntensity");
	getDimensions(w, h, c, nzs, f);
	
	for (izs = 0; izs < nzs; izs++) {
		Stack.setPosition(1, izs+1, 1);
		getStatistics(area, mean, min, max, std);
		if (max!=0) {
			run("Auto Threshold", "method=Default ignore_black white");
		}
	}
	run("8-bit");
	rename(maskedNucleoplasmImgTitle);
	run("Close-", "stack"); 
}

function getLabelBoundingBox2(label,border){
	
	// duplicate nuclei ID image
	run("Duplicate...", "duplicate");
	
	// threshold stack to keep only current nucleus
	setThreshold(label, label);
	run("Convert to Mask", "method=Default background=Dark black");
	rename("isolatedNucleus"+label);
	
	// image size
	getDimensions(sizeX, sizeY, C, sizeZ, F);

	// find the lowest plane holding the nucleus (zmin) and the highest (zmax)
	zmin = sizeZ;
	zmax = 0;
	for (z = 1; z <= sizeZ; z++)
	{
		Stack.setPosition(1, z, 1);
		getStatistics(area, mean, min, max, std, histogram);
		if(max == 255){
			if (zmin>z) {
				zmin=z;
			}
			if (zmax<z) {
				zmax=z;
			}
		}
	}
	print("zmin = "+zmin+"; zmax = "+zmax);

	// add border
	if((zmin-border)<1){
		zmin = 1;
	}else {
		zmin = zmin-border;
	}

	if((zmax+border)>sizeZ){
		zmax = sizeZ;
	}else {
		zmax = zmax+border;
	}
	print("(with border) zmin = "+zmin+"; zmax = "+zmax);
	
	// find xy bounding box
	run("Z Project...", "projection=[Max Intensity]");
	// add padding in xy by running a series of border dilations
	for (i = 0; i < border; i++) {
		run("Dilate");
	}
	roiManager("reset");
	setThreshold(100, 255);
	run("Create Selection");
	run("To Bounding Box");
	roiManager("Add");

	// select the original data stack and duplicate a cropped version
	selectWindow(originalImgTitle);
	roiManager("Select", 0);
	run("Duplicate...", "duplicate slices="+zmin+"-"+zmax);
	rename("croppedNucleus"+label);

	// cropped image size
	getDimensions(w, h, c, z, f);
	
	//convert the thresholded nucleus image back to its original value
	selectWindow("isolatedNucleus"+label);
	run("16-bit");
	run("Multiply...", "value="+label+" stack");
	run("Divide...", "value=255.000 stack");
	roiManager("Select", 0);
	run("Duplicate...", "duplicate range="+zmin+"-"+zmax);
	rename("isolatedCroppedNucleus"+label);
	
	// create cropped image holding initial data + nucleus segmentation
	//print("merging images data + nucleus segmentation: "+"croppedNucleus"+label+"wSeg");
	addChannelToImg("croppedNucleus"+label,
	"isolatedCroppedNucleus"+label,"croppedNucleus"+label+"wSeg",0);

	// close intermediates
	selectWindow("isolatedNucleus"+label);
	close();
	//selectWindow("croppedNucleus"+label);
	//close();
	//selectWindow("isolatedCroppedNucleus"+label);
	//close();
	selectWindow("MAX_isolatedNucleus"+label);
	close();
}

// builds a subfolder if it is not there, return the full path to the subFolder
// should be good PC & Mac but only tested on Mac
function mkDirIfNotThere(parentDir,newSubDir){
	list = getFileList(parentDir);
	subDirFound = 0;
	for(i=0;i<list.length;i++){
		if(list[i] == newSubDir){
			subDirFound = 1;
		}
	}
	fp = buildSubDirName(parentDir,newSubDir);
	if(subDirFound == 0){
		File.makeDirectory(fp);
	}
	return fp;
}

// generates a full path name to the subfolder newSubDir in the parent folder parentDir
// should be good PC & Mac but only tested on Mac
function  buildSubDirName(parentDir,newSubDir){
	// figure out file separator (Mac / or PC \)
	sf = 0;
	sb = 0;
	for(i=0;i<parentDir.length;i++){
		if(substring(parentDir, i, i+1) == '/'){
			sf = sf+1;
		}
		if(substring(parentDir, i, i+1) == '\\'){
			sb = sb+1;
		}
	}

	if(sf>=sb){
		fileSep = '/';
	}else{
		fileSep = '\\';
	}
	
	if( (substring(parentDir, parentDir.length-1) != '/')
		| (substring(parentDir, parentDir.length-1) != '\\')){
		parentDir = parentDir+fileSep;
		
	}
	fullPathToSubDir = parentDir+newSubDir;
	return fullPathToSubDir;
}
